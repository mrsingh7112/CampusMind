"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@levischuck";
exports.ids = ["vendor-chunks/@levischuck"];
exports.modules = {

/***/ "(rsc)/./node_modules/@levischuck/tiny-cbor/esm/cbor/cbor.js":
/*!*************************************************************!*\
  !*** ./node_modules/@levischuck/tiny-cbor/esm/cbor/cbor.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CBORTag: () => (/* binding */ CBORTag),\n/* harmony export */   decodeCBOR: () => (/* binding */ decodeCBOR),\n/* harmony export */   decodePartialCBOR: () => (/* binding */ decodePartialCBOR),\n/* harmony export */   encodeCBOR: () => (/* binding */ encodeCBOR)\n/* harmony export */ });\n/* harmony import */ var _cbor_internal_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./cbor_internal.js */ \"(rsc)/./node_modules/@levischuck/tiny-cbor/esm/cbor/cbor_internal.js\");\n\n/**\n * A value which is wrapped with a CBOR Tag.\n * Several tags are registered with defined meanings like 0 for a date string.\n * These meanings are **not interpreted** when decoded or encoded.\n *\n * This class is an immutable record.\n * If the tag number or value needs to change, then construct a new tag\n */ class CBORTag {\n    /**\n     * Wrap a value with a tag number.\n     * When encoded, this tag will be attached to the value.\n     *\n     * @param tag Tag number\n     * @param value Wrapped value\n     */ constructor(tag, value){\n        Object.defineProperty(this, \"tagId\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"tagValue\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.tagId = tag;\n        this.tagValue = value;\n    }\n    /**\n     * Read the tag number\n     */ get tag() {\n        return this.tagId;\n    }\n    /**\n     * Read the value\n     */ get value() {\n        return this.tagValue;\n    }\n}\nfunction decodeUnsignedInteger(data, argument, index) {\n    return (0,_cbor_internal_js__WEBPACK_IMPORTED_MODULE_0__.decodeLength)(data, argument, index);\n}\nfunction decodeNegativeInteger(data, argument, index) {\n    const [value, length] = decodeUnsignedInteger(data, argument, index);\n    return [\n        -value - 1,\n        length\n    ];\n}\nfunction decodeByteString(data, argument, index) {\n    const [lengthValue, lengthConsumed] = (0,_cbor_internal_js__WEBPACK_IMPORTED_MODULE_0__.decodeLength)(data, argument, index);\n    const dataStartIndex = index + lengthConsumed;\n    return [\n        new Uint8Array(data.buffer.slice(dataStartIndex, dataStartIndex + lengthValue)),\n        lengthConsumed + lengthValue\n    ];\n}\nconst TEXT_DECODER = new TextDecoder();\nfunction decodeString(data, argument, index) {\n    const [value, length] = decodeByteString(data, argument, index);\n    return [\n        TEXT_DECODER.decode(value),\n        length\n    ];\n}\nfunction decodeArray(data, argument, index) {\n    if (argument === 0) {\n        return [\n            [],\n            1\n        ];\n    }\n    const [length, lengthConsumed] = (0,_cbor_internal_js__WEBPACK_IMPORTED_MODULE_0__.decodeLength)(data, argument, index);\n    let consumedLength = lengthConsumed;\n    const value = [];\n    for(let i = 0; i < length; i++){\n        const remainingDataLength = data.byteLength - index - consumedLength;\n        if (remainingDataLength <= 0) {\n            throw new Error(\"array is not supported or well formed\");\n        }\n        const [decodedValue, consumed] = decodeNext(data, index + consumedLength);\n        value.push(decodedValue);\n        consumedLength += consumed;\n    }\n    return [\n        value,\n        consumedLength\n    ];\n}\nconst MAP_ERROR = \"Map is not supported or well formed\";\nfunction decodeMap(data, argument, index) {\n    if (argument === 0) {\n        return [\n            new Map(),\n            1\n        ];\n    }\n    const [length, lengthConsumed] = (0,_cbor_internal_js__WEBPACK_IMPORTED_MODULE_0__.decodeLength)(data, argument, index);\n    let consumedLength = lengthConsumed;\n    const result = new Map();\n    for(let i = 0; i < length; i++){\n        let remainingDataLength = data.byteLength - index - consumedLength;\n        if (remainingDataLength <= 0) {\n            throw new Error(MAP_ERROR);\n        }\n        // Load key\n        const [key, keyConsumed] = decodeNext(data, index + consumedLength);\n        consumedLength += keyConsumed;\n        remainingDataLength -= keyConsumed;\n        // Check that there's enough to have a value\n        if (remainingDataLength <= 0) {\n            throw new Error(MAP_ERROR);\n        }\n        // Technically CBOR maps can have any type as the key, and so can JS Maps\n        // However, JS Maps can only reference such keys as references which would\n        // require key iteration and pattern matching.\n        // For simplicity, since such keys are not in use with WebAuthn, this\n        // capability is not implemented and the types are restricted to strings\n        // and numbers.\n        if (typeof key !== \"string\" && typeof key !== \"number\") {\n            throw new Error(MAP_ERROR);\n        }\n        // CBOR Maps are not well formed if there are duplicate keys\n        if (result.has(key)) {\n            throw new Error(MAP_ERROR);\n        }\n        // Load value\n        const [value, valueConsumed] = decodeNext(data, index + consumedLength);\n        consumedLength += valueConsumed;\n        result.set(key, value);\n    }\n    return [\n        result,\n        consumedLength\n    ];\n}\nfunction decodeFloat16(data, index) {\n    if (index + 3 > data.byteLength) {\n        throw new Error(\"CBOR stream ended before end of Float 16\");\n    }\n    // Skip the first byte\n    const result = data.getUint16(index + 1, false);\n    // A minimal selection of supported values\n    if (result == 0x7c00) {\n        return [\n            Infinity,\n            3\n        ];\n    } else if (result == 0x7e00) {\n        return [\n            NaN,\n            3\n        ];\n    } else if (result == 0xfc00) {\n        return [\n            -Infinity,\n            3\n        ];\n    }\n    throw new Error(\"Float16 data is unsupported\");\n}\nfunction decodeFloat32(data, index) {\n    if (index + 5 > data.byteLength) {\n        throw new Error(\"CBOR stream ended before end of Float 32\");\n    }\n    // Skip the first byte\n    const result = data.getFloat32(index + 1, false);\n    // First byte + 4 byte float\n    return [\n        result,\n        5\n    ];\n}\nfunction decodeFloat64(data, index) {\n    if (index + 9 > data.byteLength) {\n        throw new Error(\"CBOR stream ended before end of Float 64\");\n    }\n    // Skip the first byte\n    const result = data.getFloat64(index + 1, false);\n    // First byte + 8 byte float\n    return [\n        result,\n        9\n    ];\n}\nfunction decodeTag(data, argument, index) {\n    const [tag, tagBytes] = (0,_cbor_internal_js__WEBPACK_IMPORTED_MODULE_0__.decodeLength)(data, argument, index);\n    const [value, valueBytes] = decodeNext(data, index + tagBytes);\n    return [\n        new CBORTag(tag, value),\n        tagBytes + valueBytes\n    ];\n}\nfunction decodeNext(data, index) {\n    if (index >= data.byteLength) {\n        throw new Error(\"CBOR stream ended before tag value\");\n    }\n    const byte = data.getUint8(index);\n    const majorType = byte >> 5;\n    const argument = byte & 0x1f;\n    switch(majorType){\n        case _cbor_internal_js__WEBPACK_IMPORTED_MODULE_0__.MAJOR_TYPE_UNSIGNED_INTEGER:\n            {\n                return decodeUnsignedInteger(data, argument, index);\n            }\n        case _cbor_internal_js__WEBPACK_IMPORTED_MODULE_0__.MAJOR_TYPE_NEGATIVE_INTEGER:\n            {\n                return decodeNegativeInteger(data, argument, index);\n            }\n        case _cbor_internal_js__WEBPACK_IMPORTED_MODULE_0__.MAJOR_TYPE_BYTE_STRING:\n            {\n                return decodeByteString(data, argument, index);\n            }\n        case _cbor_internal_js__WEBPACK_IMPORTED_MODULE_0__.MAJOR_TYPE_TEXT_STRING:\n            {\n                return decodeString(data, argument, index);\n            }\n        case _cbor_internal_js__WEBPACK_IMPORTED_MODULE_0__.MAJOR_TYPE_ARRAY:\n            {\n                return decodeArray(data, argument, index);\n            }\n        case _cbor_internal_js__WEBPACK_IMPORTED_MODULE_0__.MAJOR_TYPE_MAP:\n            {\n                return decodeMap(data, argument, index);\n            }\n        case _cbor_internal_js__WEBPACK_IMPORTED_MODULE_0__.MAJOR_TYPE_TAG:\n            {\n                return decodeTag(data, argument, index);\n            }\n        case _cbor_internal_js__WEBPACK_IMPORTED_MODULE_0__.MAJOR_TYPE_SIMPLE_OR_FLOAT:\n            {\n                switch(argument){\n                    case 20:\n                        return [\n                            false,\n                            1\n                        ];\n                    case 21:\n                        return [\n                            true,\n                            1\n                        ];\n                    case 22:\n                        return [\n                            null,\n                            1\n                        ];\n                    case 23:\n                        return [\n                            undefined,\n                            1\n                        ];\n                    // 24: Simple value (value 32..255 in following byte)\n                    case 25:\n                        return decodeFloat16(data, index);\n                    case 26:\n                        return decodeFloat32(data, index);\n                    case 27:\n                        return decodeFloat64(data, index);\n                }\n            }\n    }\n    throw new Error(`Unsupported or not well formed at ${index}`);\n}\nfunction encodeSimple(data) {\n    if (data === true) {\n        return 0xf5;\n    } else if (data === false) {\n        return 0xf4;\n    } else if (data === null) {\n        return 0xf6;\n    }\n    // Else undefined\n    return 0xf7;\n}\nfunction encodeFloat(data) {\n    if (Math.fround(data) == data || !Number.isFinite(data) || Number.isNaN(data)) {\n        // Float32\n        const output = new Uint8Array(5);\n        output[0] = 0xfa;\n        const view = new DataView(output.buffer);\n        view.setFloat32(1, data, false);\n        return output;\n    } else {\n        // Float64\n        const output = new Uint8Array(9);\n        output[0] = 0xfb;\n        const view = new DataView(output.buffer);\n        view.setFloat64(1, data, false);\n        return output;\n    }\n}\nfunction encodeNumber(data) {\n    if (typeof data == \"number\") {\n        if (Number.isSafeInteger(data)) {\n            // Encode integer\n            if (data < 0) {\n                return (0,_cbor_internal_js__WEBPACK_IMPORTED_MODULE_0__.encodeLength)(_cbor_internal_js__WEBPACK_IMPORTED_MODULE_0__.MAJOR_TYPE_NEGATIVE_INTEGER, Math.abs(data));\n            } else {\n                return (0,_cbor_internal_js__WEBPACK_IMPORTED_MODULE_0__.encodeLength)(_cbor_internal_js__WEBPACK_IMPORTED_MODULE_0__.MAJOR_TYPE_UNSIGNED_INTEGER, data);\n            }\n        }\n        return [\n            encodeFloat(data)\n        ];\n    } else {\n        if (data < 0n) {\n            return (0,_cbor_internal_js__WEBPACK_IMPORTED_MODULE_0__.encodeLength)(_cbor_internal_js__WEBPACK_IMPORTED_MODULE_0__.MAJOR_TYPE_NEGATIVE_INTEGER, data * -1n);\n        } else {\n            return (0,_cbor_internal_js__WEBPACK_IMPORTED_MODULE_0__.encodeLength)(_cbor_internal_js__WEBPACK_IMPORTED_MODULE_0__.MAJOR_TYPE_UNSIGNED_INTEGER, data);\n        }\n    }\n}\nconst ENCODER = new TextEncoder();\nfunction encodeString(data, output) {\n    output.push(...(0,_cbor_internal_js__WEBPACK_IMPORTED_MODULE_0__.encodeLength)(_cbor_internal_js__WEBPACK_IMPORTED_MODULE_0__.MAJOR_TYPE_TEXT_STRING, data.length));\n    output.push(ENCODER.encode(data));\n}\nfunction encodeBytes(data, output) {\n    output.push(...(0,_cbor_internal_js__WEBPACK_IMPORTED_MODULE_0__.encodeLength)(_cbor_internal_js__WEBPACK_IMPORTED_MODULE_0__.MAJOR_TYPE_BYTE_STRING, data.length));\n    output.push(data);\n}\nfunction encodeArray(data, output) {\n    output.push(...(0,_cbor_internal_js__WEBPACK_IMPORTED_MODULE_0__.encodeLength)(_cbor_internal_js__WEBPACK_IMPORTED_MODULE_0__.MAJOR_TYPE_ARRAY, data.length));\n    for (const element of data){\n        encodePartialCBOR(element, output);\n    }\n}\nfunction encodeMap(data, output) {\n    output.push(new Uint8Array((0,_cbor_internal_js__WEBPACK_IMPORTED_MODULE_0__.encodeLength)(_cbor_internal_js__WEBPACK_IMPORTED_MODULE_0__.MAJOR_TYPE_MAP, data.size)));\n    for (const [key, value] of data.entries()){\n        encodePartialCBOR(key, output);\n        encodePartialCBOR(value, output);\n    }\n}\nfunction encodeTag(tag, output) {\n    output.push(...(0,_cbor_internal_js__WEBPACK_IMPORTED_MODULE_0__.encodeLength)(_cbor_internal_js__WEBPACK_IMPORTED_MODULE_0__.MAJOR_TYPE_TAG, tag.tag));\n    encodePartialCBOR(tag.value, output);\n}\nfunction encodePartialCBOR(data, output) {\n    if (typeof data == \"boolean\" || data === null || data == undefined) {\n        output.push(encodeSimple(data));\n        return;\n    }\n    if (typeof data == \"number\" || typeof data == \"bigint\") {\n        output.push(...encodeNumber(data));\n        return;\n    }\n    if (typeof data == \"string\") {\n        encodeString(data, output);\n        return;\n    }\n    if (data instanceof Uint8Array) {\n        encodeBytes(data, output);\n        return;\n    }\n    if (Array.isArray(data)) {\n        encodeArray(data, output);\n        return;\n    }\n    if (data instanceof Map) {\n        encodeMap(data, output);\n        return;\n    }\n    if (data instanceof CBORTag) {\n        encodeTag(data, output);\n        return;\n    }\n    throw new Error(\"Not implemented\");\n}\n/**\n * Like {decodeCBOR}, but the length of the data is unknown and there is likely\n * more -- possibly unrelated non-CBOR -- data afterwards.\n *\n * Examples:\n *\n * ```ts\n * import {decodePartialCBOR} from './cbor.ts'\n * decodePartialCBOR(new Uint8Array([1, 2, 245, 3, 4]), 2)\n * // returns [true, 1]\n * // It did not decode the leading [1, 2] or trailing [3, 4]\n * ```\n *\n * @param data a data stream to read data from\n * @param index where to start reading in the data stream\n * @returns a tuple of the value followed by bytes read.\n * @throws {Error}\n *   When the data stream ends early or the CBOR data is not well formed\n */ function decodePartialCBOR(data, index) {\n    if (data.byteLength === 0 || data.byteLength <= index || index < 0) {\n        throw new Error(\"No data\");\n    }\n    if (data instanceof Uint8Array) {\n        return decodeNext(new DataView(data.buffer), index);\n    } else if (data instanceof ArrayBuffer) {\n        return decodeNext(new DataView(data), index);\n    }\n    // otherwise, it is a data view\n    return decodeNext(data, index);\n}\n/**\n * Decode CBOR data from a binary stream\n *\n * The entire data stream from [0, length) will be consumed.\n * If you require a partial decoding, see {decodePartialCBOR}.\n *\n * Examples:\n *\n * ```ts\n * import {decodeCBOR, CBORTag, CBORType} from './cbor.ts'\n * decodeCBOR(new Uint8Array([162, 99, 107, 101, 121, 101, 118, 97, 108, 117, 101, 1, 109, 97, 110, 111, 116, 104, 101, 114, 32, 118, 97, 108, 117, 101]));\n * // returns new Map<string | number, CBORType>([\n * //   [\"key\", \"value\"],\n * //   [1, \"another value\"]\n * // ]);\n *\n * const taggedItem = new Uint8Array([217, 4, 210, 101, 104, 101, 108, 108, 111]);\n * decodeCBOR(new DataView(taggedItem.buffer))\n * // returns new CBORTag(1234, \"hello\")\n * ```\n *\n * @param data a data stream, multiple types are supported\n * @returns\n */ function decodeCBOR(data) {\n    const [value, length] = decodePartialCBOR(data, 0);\n    if (length !== data.byteLength) {\n        throw new Error(`Data was decoded, but the whole stream was not processed ${length} != ${data.byteLength}`);\n    }\n    return value;\n}\n/**\n * Encode a supported structure to a CBOR byte string.\n *\n * Example:\n *\n * ```ts\n * import {encodeCBOR, CBORType, CBORTag} from './cbor.ts'\n * encodeCBOR(new Map<string | number, CBORType>([\n *   [\"key\", \"value\"],\n *   [1, \"another value\"]\n * ]));\n * // returns new Uint8Array([162, 99, 107, 101, 121, 101, 118, 97, 108, 117, 101, 1, 109, 97, 110, 111, 116, 104, 101, 114, 32 118, 97, 108, 117, 101])\n *\n * encodeCBOR(new CBORTag(1234, \"hello\"))\n * // returns new UInt8Array([217, 4, 210, 101, 104, 101, 108, 108, 111])\n * ```\n *\n * @param data Data to encode\n * @returns A byte string as a Uint8Array\n * @throws Error\n *   if unsupported data is found during encoding\n */ function encodeCBOR(data) {\n    const results = [];\n    encodePartialCBOR(data, results);\n    let length = 0;\n    for (const result of results){\n        if (typeof result == \"number\") {\n            length += 1;\n        } else {\n            length += result.length;\n        }\n    }\n    const output = new Uint8Array(length);\n    let index = 0;\n    for (const result of results){\n        if (typeof result == \"number\") {\n            output[index] = result;\n            index += 1;\n        } else {\n            output.set(result, index);\n            index += result.length;\n        }\n    }\n    return output;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxldmlzY2h1Y2svdGlueS1jYm9yL2VzbS9jYm9yL2Nib3IuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBeVA7QUFDelA7Ozs7Ozs7Q0FPQyxHQUNNLE1BQU1VO0lBQ1Q7Ozs7OztLQU1DLEdBQ0RDLFlBQVlDLEdBQUcsRUFBRUMsS0FBSyxDQUFFO1FBQ3BCQyxPQUFPQyxjQUFjLENBQUMsSUFBSSxFQUFFLFNBQVM7WUFDakNDLFlBQVk7WUFDWkMsY0FBYztZQUNkQyxVQUFVO1lBQ1ZMLE9BQU8sS0FBSztRQUNoQjtRQUNBQyxPQUFPQyxjQUFjLENBQUMsSUFBSSxFQUFFLFlBQVk7WUFDcENDLFlBQVk7WUFDWkMsY0FBYztZQUNkQyxVQUFVO1lBQ1ZMLE9BQU8sS0FBSztRQUNoQjtRQUNBLElBQUksQ0FBQ00sS0FBSyxHQUFHUDtRQUNiLElBQUksQ0FBQ1EsUUFBUSxHQUFHUDtJQUNwQjtJQUNBOztLQUVDLEdBQ0QsSUFBSUQsTUFBTTtRQUNOLE9BQU8sSUFBSSxDQUFDTyxLQUFLO0lBQ3JCO0lBQ0E7O0tBRUMsR0FDRCxJQUFJTixRQUFRO1FBQ1IsT0FBTyxJQUFJLENBQUNPLFFBQVE7SUFDeEI7QUFDSjtBQUNBLFNBQVNDLHNCQUFzQkMsSUFBSSxFQUFFQyxRQUFRLEVBQUVDLEtBQUs7SUFDaEQsT0FBT3hCLCtEQUFZQSxDQUFDc0IsTUFBTUMsVUFBVUM7QUFDeEM7QUFDQSxTQUFTQyxzQkFBc0JILElBQUksRUFBRUMsUUFBUSxFQUFFQyxLQUFLO0lBQ2hELE1BQU0sQ0FBQ1gsT0FBT2EsT0FBTyxHQUFHTCxzQkFBc0JDLE1BQU1DLFVBQVVDO0lBQzlELE9BQU87UUFBQyxDQUFDWCxRQUFRO1FBQUdhO0tBQU87QUFDL0I7QUFDQSxTQUFTQyxpQkFBaUJMLElBQUksRUFBRUMsUUFBUSxFQUFFQyxLQUFLO0lBQzNDLE1BQU0sQ0FBQ0ksYUFBYUMsZUFBZSxHQUFHN0IsK0RBQVlBLENBQUNzQixNQUFNQyxVQUFVQztJQUNu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M0I7WUFDbkJBLFNBQVMyQixPQUFPekIsTUFBTTtRQUMxQjtJQUNKO0lBQ0EsT0FBT3FEO0FBQ1giLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jYW1wdXMtbWluZC8uL25vZGVfbW9kdWxlcy9AbGV2aXNjaHVjay90aW55LWNib3IvZXNtL2Nib3IvY2Jvci5qcz82NjUwIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGRlY29kZUxlbmd0aCwgZW5jb2RlTGVuZ3RoLCBNQUpPUl9UWVBFX0FSUkFZLCBNQUpPUl9UWVBFX0JZVEVfU1RSSU5HLCBNQUpPUl9UWVBFX01BUCwgTUFKT1JfVFlQRV9ORUdBVElWRV9JTlRFR0VSLCBNQUpPUl9UWVBFX1NJTVBMRV9PUl9GTE9BVCwgTUFKT1JfVFlQRV9UQUcsIE1BSk9SX1RZUEVfVEVYVF9TVFJJTkcsIE1BSk9SX1RZUEVfVU5TSUdORURfSU5URUdFUiwgfSBmcm9tIFwiLi9jYm9yX2ludGVybmFsLmpzXCI7XG4vKipcbiAqIEEgdmFsdWUgd2hpY2ggaXMgd3JhcHBlZCB3aXRoIGEgQ0JPUiBUYWcuXG4gKiBTZXZlcmFsIHRhZ3MgYXJlIHJlZ2lzdGVyZWQgd2l0aCBkZWZpbmVkIG1lYW5pbmdzIGxpa2UgMCBmb3IgYSBkYXRlIHN0cmluZy5cbiAqIFRoZXNlIG1lYW5pbmdzIGFyZSAqKm5vdCBpbnRlcnByZXRlZCoqIHdoZW4gZGVjb2RlZCBvciBlbmNvZGVkLlxuICpcbiAqIFRoaXMgY2xhc3MgaXMgYW4gaW1tdXRhYmxlIHJlY29yZC5cbiAqIElmIHRoZSB0YWcgbnVtYmVyIG9yIHZhbHVlIG5lZWRzIHRvIGNoYW5nZSwgdGhlbiBjb25zdHJ1Y3QgYSBuZXcgdGFnXG4gKi9cbmV4cG9ydCBjbGFzcyBDQk9SVGFnIHtcbiAgICAvKipcbiAgICAgKiBXcmFwIGEgdmFsdWUgd2l0aCBhIHRhZyBudW1iZXIuXG4gICAgICogV2hlbiBlbmNvZGVkLCB0aGlzIHRhZyB3aWxsIGJlIGF0dGFjaGVkIHRvIHRoZSB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB0YWcgVGFnIG51bWJlclxuICAgICAqIEBwYXJhbSB2YWx1ZSBXcmFwcGVkIHZhbHVlXG4gICAgICovXG4gICAgY29uc3RydWN0b3IodGFnLCB2YWx1ZSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ0YWdJZFwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ0YWdWYWx1ZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnRhZ0lkID0gdGFnO1xuICAgICAgICB0aGlzLnRhZ1ZhbHVlID0gdmFsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlYWQgdGhlIHRhZyBudW1iZXJcbiAgICAgKi9cbiAgICBnZXQgdGFnKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50YWdJZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVhZCB0aGUgdmFsdWVcbiAgICAgKi9cbiAgICBnZXQgdmFsdWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRhZ1ZhbHVlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGRlY29kZVVuc2lnbmVkSW50ZWdlcihkYXRhLCBhcmd1bWVudCwgaW5kZXgpIHtcbiAgICByZXR1cm4gZGVjb2RlTGVuZ3RoKGRhdGEsIGFyZ3VtZW50LCBpbmRleCk7XG59XG5mdW5jdGlvbiBkZWNvZGVOZWdhdGl2ZUludGVnZXIoZGF0YSwgYXJndW1lbnQsIGluZGV4KSB7XG4gICAgY29uc3QgW3ZhbHVlLCBsZW5ndGhdID0gZGVjb2RlVW5zaWduZWRJbnRlZ2VyKGRhdGEsIGFyZ3VtZW50LCBpbmRleCk7XG4gICAgcmV0dXJuIFstdmFsdWUgLSAxLCBsZW5ndGhdO1xufVxuZnVuY3Rpb24gZGVjb2RlQnl0ZVN0cmluZyhkYXRhLCBhcmd1bWVudCwgaW5kZXgpIHtcbiAgICBjb25zdCBbbGVuZ3RoVmFsdWUsIGxlbmd0aENvbnN1bWVkXSA9IGRlY29kZUxlbmd0aChkYXRhLCBhcmd1bWVudCwgaW5kZXgpO1xuICAgIGNvbnN0IGRhdGFTdGFydEluZGV4ID0gaW5kZXggKyBsZW5ndGhDb25zdW1lZDtcbiAgICByZXR1cm4gW1xuICAgICAgICBuZXcgVWludDhBcnJheShkYXRhLmJ1ZmZlci5zbGljZShkYXRhU3RhcnRJbmRleCwgZGF0YVN0YXJ0SW5kZXggKyBsZW5ndGhWYWx1ZSkpLFxuICAgICAgICBsZW5ndGhDb25zdW1lZCArIGxlbmd0aFZhbHVlLFxuICAgIF07XG59XG5jb25zdCBURVhUX0RFQ09ERVIgPSBuZXcgVGV4dERlY29kZXIoKTtcbmZ1bmN0aW9uIGRlY29kZVN0cmluZyhkYXRhLCBhcmd1bWVudCwgaW5kZXgpIHtcbiAgICBjb25zdCBbdmFsdWUsIGxlbmd0aF0gPSBkZWNvZGVCeXRlU3RyaW5nKGRhdGEsIGFyZ3VtZW50LCBpbmRleCk7XG4gICAgcmV0dXJuIFtURVhUX0RFQ09ERVIuZGVjb2RlKHZhbHVlKSwgbGVuZ3RoXTtcbn1cbmZ1bmN0aW9uIGRlY29kZUFycmF5KGRhdGEsIGFyZ3VtZW50LCBpbmRleCkge1xuICAgIGlmIChhcmd1bWVudCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gW1tdLCAxXTtcbiAgICB9XG4gICAgY29uc3QgW2xlbmd0aCwgbGVuZ3RoQ29uc3VtZWRdID0gZGVjb2RlTGVuZ3RoKGRhdGEsIGFyZ3VtZW50LCBpbmRleCk7XG4gICAgbGV0IGNvbnN1bWVkTGVuZ3RoID0gbGVuZ3RoQ29uc3VtZWQ7XG4gICAgY29uc3QgdmFsdWUgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHJlbWFpbmluZ0RhdGFMZW5ndGggPSBkYXRhLmJ5dGVMZW5ndGggLSBpbmRleCAtIGNvbnN1bWVkTGVuZ3RoO1xuICAgICAgICBpZiAocmVtYWluaW5nRGF0YUxlbmd0aCA8PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJhcnJheSBpcyBub3Qgc3VwcG9ydGVkIG9yIHdlbGwgZm9ybWVkXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IFtkZWNvZGVkVmFsdWUsIGNvbnN1bWVkXSA9IGRlY29kZU5leHQoZGF0YSwgaW5kZXggKyBjb25zdW1lZExlbmd0aCk7XG4gICAgICAgIHZhbHVlLnB1c2goZGVjb2RlZFZhbHVlKTtcbiAgICAgICAgY29uc3VtZWRMZW5ndGggKz0gY29uc3VtZWQ7XG4gICAgfVxuICAgIHJldHVybiBbdmFsdWUsIGNvbnN1bWVkTGVuZ3RoXTtcbn1cbmNvbnN0IE1BUF9FUlJPUiA9IFwiTWFwIGlzIG5vdCBzdXBwb3J0ZWQgb3Igd2VsbCBmb3JtZWRcIjtcbmZ1bmN0aW9uIGRlY29kZU1hcChkYXRhLCBhcmd1bWVudCwgaW5kZXgpIHtcbiAgICBpZiAoYXJndW1lbnQgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIFtuZXcgTWFwKCksIDFdO1xuICAgIH1cbiAgICBjb25zdCBbbGVuZ3RoLCBsZW5ndGhDb25zdW1lZF0gPSBkZWNvZGVMZW5ndGgoZGF0YSwgYXJndW1lbnQsIGluZGV4KTtcbiAgICBsZXQgY29uc3VtZWRMZW5ndGggPSBsZW5ndGhDb25zdW1lZDtcbiAgICBjb25zdCByZXN1bHQgPSBuZXcgTWFwKCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgcmVtYWluaW5nRGF0YUxlbmd0aCA9IGRhdGEuYnl0ZUxlbmd0aCAtIGluZGV4IC0gY29uc3VtZWRMZW5ndGg7XG4gICAgICAgIGlmIChyZW1haW5pbmdEYXRhTGVuZ3RoIDw9IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihNQVBfRVJST1IpO1xuICAgICAgICB9XG4gICAgICAgIC8vIExvYWQga2V5XG4gICAgICAgIGNvbnN0IFtrZXksIGtleUNvbnN1bWVkXSA9IGRlY29kZU5leHQoZGF0YSwgaW5kZXggKyBjb25zdW1lZExlbmd0aCk7XG4gICAgICAgIGNvbnN1bWVkTGVuZ3RoICs9IGtleUNvbnN1bWVkO1xuICAgICAgICByZW1haW5pbmdEYXRhTGVuZ3RoIC09IGtleUNvbnN1bWVkO1xuICAgICAgICAvLyBDaGVjayB0aGF0IHRoZXJlJ3MgZW5vdWdoIHRvIGhhdmUgYSB2YWx1ZVxuICAgICAgICBpZiAocmVtYWluaW5nRGF0YUxlbmd0aCA8PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoTUFQX0VSUk9SKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUZWNobmljYWxseSBDQk9SIG1hcHMgY2FuIGhhdmUgYW55IHR5cGUgYXMgdGhlIGtleSwgYW5kIHNvIGNhbiBKUyBNYXBzXG4gICAgICAgIC8vIEhvd2V2ZXIsIEpTIE1hcHMgY2FuIG9ubHkgcmVmZXJlbmNlIHN1Y2gga2V5cyBhcyByZWZlcmVuY2VzIHdoaWNoIHdvdWxkXG4gICAgICAgIC8vIHJlcXVpcmUga2V5IGl0ZXJhdGlvbiBhbmQgcGF0dGVybiBtYXRjaGluZy5cbiAgICAgICAgLy8gRm9yIHNpbXBsaWNpdHksIHNpbmNlIHN1Y2gga2V5cyBhcmUgbm90IGluIHVzZSB3aXRoIFdlYkF1dGhuLCB0aGlzXG4gICAgICAgIC8vIGNhcGFiaWxpdHkgaXMgbm90IGltcGxlbWVudGVkIGFuZCB0aGUgdHlwZXMgYXJlIHJlc3RyaWN0ZWQgdG8gc3RyaW5nc1xuICAgICAgICAvLyBhbmQgbnVtYmVycy5cbiAgICAgICAgaWYgKHR5cGVvZiBrZXkgIT09IFwic3RyaW5nXCIgJiYgdHlwZW9mIGtleSAhPT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKE1BUF9FUlJPUik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ0JPUiBNYXBzIGFyZSBub3Qgd2VsbCBmb3JtZWQgaWYgdGhlcmUgYXJlIGR1cGxpY2F0ZSBrZXlzXG4gICAgICAgIGlmIChyZXN1bHQuaGFzKGtleSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihNQVBfRVJST1IpO1xuICAgICAgICB9XG4gICAgICAgIC8vIExvYWQgdmFsdWVcbiAgICAgICAgY29uc3QgW3ZhbHVlLCB2YWx1ZUNvbnN1bWVkXSA9IGRlY29kZU5leHQoZGF0YSwgaW5kZXggKyBjb25zdW1lZExlbmd0aCk7XG4gICAgICAgIGNvbnN1bWVkTGVuZ3RoICs9IHZhbHVlQ29uc3VtZWQ7XG4gICAgICAgIHJlc3VsdC5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiBbcmVzdWx0LCBjb25zdW1lZExlbmd0aF07XG59XG5mdW5jdGlvbiBkZWNvZGVGbG9hdDE2KGRhdGEsIGluZGV4KSB7XG4gICAgaWYgKGluZGV4ICsgMyA+IGRhdGEuYnl0ZUxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDQk9SIHN0cmVhbSBlbmRlZCBiZWZvcmUgZW5kIG9mIEZsb2F0IDE2XCIpO1xuICAgIH1cbiAgICAvLyBTa2lwIHRoZSBmaXJzdCBieXRlXG4gICAgY29uc3QgcmVzdWx0ID0gZGF0YS5nZXRVaW50MTYoaW5kZXggKyAxLCBmYWxzZSk7XG4gICAgLy8gQSBtaW5pbWFsIHNlbGVjdGlvbiBvZiBzdXBwb3J0ZWQgdmFsdWVzXG4gICAgaWYgKHJlc3VsdCA9PSAweDdjMDApIHtcbiAgICAgICAgcmV0dXJuIFtJbmZpbml0eSwgM107XG4gICAgfVxuICAgIGVsc2UgaWYgKHJlc3VsdCA9PSAweDdlMDApIHtcbiAgICAgICAgcmV0dXJuIFtOYU4sIDNdO1xuICAgIH1cbiAgICBlbHNlIGlmIChyZXN1bHQgPT0gMHhmYzAwKSB7XG4gICAgICAgIHJldHVybiBbLUluZmluaXR5LCAzXTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiRmxvYXQxNiBkYXRhIGlzIHVuc3VwcG9ydGVkXCIpO1xufVxuZnVuY3Rpb24gZGVjb2RlRmxvYXQzMihkYXRhLCBpbmRleCkge1xuICAgIGlmIChpbmRleCArIDUgPiBkYXRhLmJ5dGVMZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ0JPUiBzdHJlYW0gZW5kZWQgYmVmb3JlIGVuZCBvZiBGbG9hdCAzMlwiKTtcbiAgICB9XG4gICAgLy8gU2tpcCB0aGUgZmlyc3QgYnl0ZVxuICAgIGNvbnN0IHJlc3VsdCA9IGRhdGEuZ2V0RmxvYXQzMihpbmRleCArIDEsIGZhbHNlKTtcbiAgICAvLyBGaXJzdCBieXRlICsgNCBieXRlIGZsb2F0XG4gICAgcmV0dXJuIFtyZXN1bHQsIDVdO1xufVxuZnVuY3Rpb24gZGVjb2RlRmxvYXQ2NChkYXRhLCBpbmRleCkge1xuICAgIGlmIChpbmRleCArIDkgPiBkYXRhLmJ5dGVMZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ0JPUiBzdHJlYW0gZW5kZWQgYmVmb3JlIGVuZCBvZiBGbG9hdCA2NFwiKTtcbiAgICB9XG4gICAgLy8gU2tpcCB0aGUgZmlyc3QgYnl0ZVxuICAgIGNvbnN0IHJlc3VsdCA9IGRhdGEuZ2V0RmxvYXQ2NChpbmRleCArIDEsIGZhbHNlKTtcbiAgICAvLyBGaXJzdCBieXRlICsgOCBieXRlIGZsb2F0XG4gICAgcmV0dXJuIFtyZXN1bHQsIDldO1xufVxuZnVuY3Rpb24gZGVjb2RlVGFnKGRhdGEsIGFyZ3VtZW50LCBpbmRleCkge1xuICAgIGNvbnN0IFt0YWcsIHRhZ0J5dGVzXSA9IGRlY29kZUxlbmd0aChkYXRhLCBhcmd1bWVudCwgaW5kZXgpO1xuICAgIGNvbnN0IFt2YWx1ZSwgdmFsdWVCeXRlc10gPSBkZWNvZGVOZXh0KGRhdGEsIGluZGV4ICsgdGFnQnl0ZXMpO1xuICAgIHJldHVybiBbbmV3IENCT1JUYWcodGFnLCB2YWx1ZSksIHRhZ0J5dGVzICsgdmFsdWVCeXRlc107XG59XG5mdW5jdGlvbiBkZWNvZGVOZXh0KGRhdGEsIGluZGV4KSB7XG4gICAgaWYgKGluZGV4ID49IGRhdGEuYnl0ZUxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDQk9SIHN0cmVhbSBlbmRlZCBiZWZvcmUgdGFnIHZhbHVlXCIpO1xuICAgIH1cbiAgICBjb25zdCBieXRlID0gZGF0YS5nZXRVaW50OChpbmRleCk7XG4gICAgY29uc3QgbWFqb3JUeXBlID0gYnl0ZSA+PiA1O1xuICAgIGNvbnN0IGFyZ3VtZW50ID0gYnl0ZSAmIDB4MWY7XG4gICAgc3dpdGNoIChtYWpvclR5cGUpIHtcbiAgICAgICAgY2FzZSBNQUpPUl9UWVBFX1VOU0lHTkVEX0lOVEVHRVI6IHtcbiAgICAgICAgICAgIHJldHVybiBkZWNvZGVVbnNpZ25lZEludGVnZXIoZGF0YSwgYXJndW1lbnQsIGluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlIE1BSk9SX1RZUEVfTkVHQVRJVkVfSU5URUdFUjoge1xuICAgICAgICAgICAgcmV0dXJuIGRlY29kZU5lZ2F0aXZlSW50ZWdlcihkYXRhLCBhcmd1bWVudCwgaW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgTUFKT1JfVFlQRV9CWVRFX1NUUklORzoge1xuICAgICAgICAgICAgcmV0dXJuIGRlY29kZUJ5dGVTdHJpbmcoZGF0YSwgYXJndW1lbnQsIGluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlIE1BSk9SX1RZUEVfVEVYVF9TVFJJTkc6IHtcbiAgICAgICAgICAgIHJldHVybiBkZWNvZGVTdHJpbmcoZGF0YSwgYXJndW1lbnQsIGluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlIE1BSk9SX1RZUEVfQVJSQVk6IHtcbiAgICAgICAgICAgIHJldHVybiBkZWNvZGVBcnJheShkYXRhLCBhcmd1bWVudCwgaW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgTUFKT1JfVFlQRV9NQVA6IHtcbiAgICAgICAgICAgIHJldHVybiBkZWNvZGVNYXAoZGF0YSwgYXJndW1lbnQsIGluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlIE1BSk9SX1RZUEVfVEFHOiB7XG4gICAgICAgICAgICByZXR1cm4gZGVjb2RlVGFnKGRhdGEsIGFyZ3VtZW50LCBpbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBNQUpPUl9UWVBFX1NJTVBMRV9PUl9GTE9BVDoge1xuICAgICAgICAgICAgc3dpdGNoIChhcmd1bWVudCkge1xuICAgICAgICAgICAgICAgIGNhc2UgMjA6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbZmFsc2UsIDFdO1xuICAgICAgICAgICAgICAgIGNhc2UgMjE6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbdHJ1ZSwgMV07XG4gICAgICAgICAgICAgICAgY2FzZSAyMjpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtudWxsLCAxXTtcbiAgICAgICAgICAgICAgICBjYXNlIDIzOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW3VuZGVmaW5lZCwgMV07XG4gICAgICAgICAgICAgICAgLy8gMjQ6IFNpbXBsZSB2YWx1ZSAodmFsdWUgMzIuLjI1NSBpbiBmb2xsb3dpbmcgYnl0ZSlcbiAgICAgICAgICAgICAgICBjYXNlIDI1OiAvLyBJRUVFIDc1NCBIYWxmLVByZWNpc2lvbiBGbG9hdCAoMTYgYml0cyBmb2xsb3cpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkZWNvZGVGbG9hdDE2KGRhdGEsIGluZGV4KTtcbiAgICAgICAgICAgICAgICBjYXNlIDI2OiAvLyBJRUVFIDc1NCBTaW5nbGUtUHJlY2lzaW9uIEZsb2F0ICgzMiBiaXRzIGZvbGxvdylcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRlY29kZUZsb2F0MzIoZGF0YSwgaW5kZXgpO1xuICAgICAgICAgICAgICAgIGNhc2UgMjc6IC8vIElFRUUgNzU0IERvdWJsZS1QcmVjaXNpb24gRmxvYXQgKDY0IGJpdHMgZm9sbG93KVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGVjb2RlRmxvYXQ2NChkYXRhLCBpbmRleCk7XG4gICAgICAgICAgICAgICAgLy8gMjgtMzA6IFJlc2VydmVkLCBub3Qgd2VsbC1mb3JtZWQgaW4gdGhlIHByZXNlbnQgZG9jdW1lbnRcbiAgICAgICAgICAgICAgICAvLyAzMTogXCJicmVha1wiIHN0b3AgY29kZSBmb3IgaW5kZWZpbml0ZS1sZW5ndGggaXRlbXNcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIG9yIG5vdCB3ZWxsIGZvcm1lZCBhdCAke2luZGV4fWApO1xufVxuZnVuY3Rpb24gZW5jb2RlU2ltcGxlKGRhdGEpIHtcbiAgICBpZiAoZGF0YSA9PT0gdHJ1ZSkge1xuICAgICAgICByZXR1cm4gMHhmNTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZGF0YSA9PT0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuIDB4ZjQ7XG4gICAgfVxuICAgIGVsc2UgaWYgKGRhdGEgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIDB4ZjY7XG4gICAgfVxuICAgIC8vIEVsc2UgdW5kZWZpbmVkXG4gICAgcmV0dXJuIDB4Zjc7XG59XG5mdW5jdGlvbiBlbmNvZGVGbG9hdChkYXRhKSB7XG4gICAgaWYgKE1hdGguZnJvdW5kKGRhdGEpID09IGRhdGEgfHwgIU51bWJlci5pc0Zpbml0ZShkYXRhKSB8fCBOdW1iZXIuaXNOYU4oZGF0YSkpIHtcbiAgICAgICAgLy8gRmxvYXQzMlxuICAgICAgICBjb25zdCBvdXRwdXQgPSBuZXcgVWludDhBcnJheSg1KTtcbiAgICAgICAgb3V0cHV0WzBdID0gMHhmYTtcbiAgICAgICAgY29uc3QgdmlldyA9IG5ldyBEYXRhVmlldyhvdXRwdXQuYnVmZmVyKTtcbiAgICAgICAgdmlldy5zZXRGbG9hdDMyKDEsIGRhdGEsIGZhbHNlKTtcbiAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIEZsb2F0NjRcbiAgICAgICAgY29uc3Qgb3V0cHV0ID0gbmV3IFVpbnQ4QXJyYXkoOSk7XG4gICAgICAgIG91dHB1dFswXSA9IDB4ZmI7XG4gICAgICAgIGNvbnN0IHZpZXcgPSBuZXcgRGF0YVZpZXcob3V0cHV0LmJ1ZmZlcik7XG4gICAgICAgIHZpZXcuc2V0RmxvYXQ2NCgxLCBkYXRhLCBmYWxzZSk7XG4gICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfVxufVxuZnVuY3Rpb24gZW5jb2RlTnVtYmVyKGRhdGEpIHtcbiAgICBpZiAodHlwZW9mIGRhdGEgPT0gXCJudW1iZXJcIikge1xuICAgICAgICBpZiAoTnVtYmVyLmlzU2FmZUludGVnZXIoZGF0YSkpIHtcbiAgICAgICAgICAgIC8vIEVuY29kZSBpbnRlZ2VyXG4gICAgICAgICAgICBpZiAoZGF0YSA8IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZW5jb2RlTGVuZ3RoKE1BSk9SX1RZUEVfTkVHQVRJVkVfSU5URUdFUiwgTWF0aC5hYnMoZGF0YSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVuY29kZUxlbmd0aChNQUpPUl9UWVBFX1VOU0lHTkVEX0lOVEVHRVIsIGRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbZW5jb2RlRmxvYXQoZGF0YSldO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKGRhdGEgPCAwbikge1xuICAgICAgICAgICAgcmV0dXJuIGVuY29kZUxlbmd0aChNQUpPUl9UWVBFX05FR0FUSVZFX0lOVEVHRVIsIGRhdGEgKiAtMW4pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGVuY29kZUxlbmd0aChNQUpPUl9UWVBFX1VOU0lHTkVEX0lOVEVHRVIsIGRhdGEpO1xuICAgICAgICB9XG4gICAgfVxufVxuY29uc3QgRU5DT0RFUiA9IG5ldyBUZXh0RW5jb2RlcigpO1xuZnVuY3Rpb24gZW5jb2RlU3RyaW5nKGRhdGEsIG91dHB1dCkge1xuICAgIG91dHB1dC5wdXNoKC4uLmVuY29kZUxlbmd0aChNQUpPUl9UWVBFX1RFWFRfU1RSSU5HLCBkYXRhLmxlbmd0aCkpO1xuICAgIG91dHB1dC5wdXNoKEVOQ09ERVIuZW5jb2RlKGRhdGEpKTtcbn1cbmZ1bmN0aW9uIGVuY29kZUJ5dGVzKGRhdGEsIG91dHB1dCkge1xuICAgIG91dHB1dC5wdXNoKC4uLmVuY29kZUxlbmd0aChNQUpPUl9UWVBFX0JZVEVfU1RSSU5HLCBkYXRhLmxlbmd0aCkpO1xuICAgIG91dHB1dC5wdXNoKGRhdGEpO1xufVxuZnVuY3Rpb24gZW5jb2RlQXJyYXkoZGF0YSwgb3V0cHV0KSB7XG4gICAgb3V0cHV0LnB1c2goLi4uZW5jb2RlTGVuZ3RoKE1BSk9SX1RZUEVfQVJSQVksIGRhdGEubGVuZ3RoKSk7XG4gICAgZm9yIChjb25zdCBlbGVtZW50IG9mIGRhdGEpIHtcbiAgICAgICAgZW5jb2RlUGFydGlhbENCT1IoZWxlbWVudCwgb3V0cHV0KTtcbiAgICB9XG59XG5mdW5jdGlvbiBlbmNvZGVNYXAoZGF0YSwgb3V0cHV0KSB7XG4gICAgb3V0cHV0LnB1c2gobmV3IFVpbnQ4QXJyYXkoZW5jb2RlTGVuZ3RoKE1BSk9SX1RZUEVfTUFQLCBkYXRhLnNpemUpKSk7XG4gICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgZGF0YS5lbnRyaWVzKCkpIHtcbiAgICAgICAgZW5jb2RlUGFydGlhbENCT1Ioa2V5LCBvdXRwdXQpO1xuICAgICAgICBlbmNvZGVQYXJ0aWFsQ0JPUih2YWx1ZSwgb3V0cHV0KTtcbiAgICB9XG59XG5mdW5jdGlvbiBlbmNvZGVUYWcodGFnLCBvdXRwdXQpIHtcbiAgICBvdXRwdXQucHVzaCguLi5lbmNvZGVMZW5ndGgoTUFKT1JfVFlQRV9UQUcsIHRhZy50YWcpKTtcbiAgICBlbmNvZGVQYXJ0aWFsQ0JPUih0YWcudmFsdWUsIG91dHB1dCk7XG59XG5mdW5jdGlvbiBlbmNvZGVQYXJ0aWFsQ0JPUihkYXRhLCBvdXRwdXQpIHtcbiAgICBpZiAodHlwZW9mIGRhdGEgPT0gXCJib29sZWFuXCIgfHwgZGF0YSA9PT0gbnVsbCB8fCBkYXRhID09IHVuZGVmaW5lZCkge1xuICAgICAgICBvdXRwdXQucHVzaChlbmNvZGVTaW1wbGUoZGF0YSkpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0eXBlb2YgZGF0YSA9PSBcIm51bWJlclwiIHx8IHR5cGVvZiBkYXRhID09IFwiYmlnaW50XCIpIHtcbiAgICAgICAgb3V0cHV0LnB1c2goLi4uZW5jb2RlTnVtYmVyKGRhdGEpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGRhdGEgPT0gXCJzdHJpbmdcIikge1xuICAgICAgICBlbmNvZGVTdHJpbmcoZGF0YSwgb3V0cHV0KTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoZGF0YSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICAgICAgZW5jb2RlQnl0ZXMoZGF0YSwgb3V0cHV0KTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoQXJyYXkuaXNBcnJheShkYXRhKSkge1xuICAgICAgICBlbmNvZGVBcnJheShkYXRhLCBvdXRwdXQpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChkYXRhIGluc3RhbmNlb2YgTWFwKSB7XG4gICAgICAgIGVuY29kZU1hcChkYXRhLCBvdXRwdXQpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChkYXRhIGluc3RhbmNlb2YgQ0JPUlRhZykge1xuICAgICAgICBlbmNvZGVUYWcoZGF0YSwgb3V0cHV0KTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJOb3QgaW1wbGVtZW50ZWRcIik7XG59XG4vKipcbiAqIExpa2Uge2RlY29kZUNCT1J9LCBidXQgdGhlIGxlbmd0aCBvZiB0aGUgZGF0YSBpcyB1bmtub3duIGFuZCB0aGVyZSBpcyBsaWtlbHlcbiAqIG1vcmUgLS0gcG9zc2libHkgdW5yZWxhdGVkIG5vbi1DQk9SIC0tIGRhdGEgYWZ0ZXJ3YXJkcy5cbiAqXG4gKiBFeGFtcGxlczpcbiAqXG4gKiBgYGB0c1xuICogaW1wb3J0IHtkZWNvZGVQYXJ0aWFsQ0JPUn0gZnJvbSAnLi9jYm9yLnRzJ1xuICogZGVjb2RlUGFydGlhbENCT1IobmV3IFVpbnQ4QXJyYXkoWzEsIDIsIDI0NSwgMywgNF0pLCAyKVxuICogLy8gcmV0dXJucyBbdHJ1ZSwgMV1cbiAqIC8vIEl0IGRpZCBub3QgZGVjb2RlIHRoZSBsZWFkaW5nIFsxLCAyXSBvciB0cmFpbGluZyBbMywgNF1cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBkYXRhIGEgZGF0YSBzdHJlYW0gdG8gcmVhZCBkYXRhIGZyb21cbiAqIEBwYXJhbSBpbmRleCB3aGVyZSB0byBzdGFydCByZWFkaW5nIGluIHRoZSBkYXRhIHN0cmVhbVxuICogQHJldHVybnMgYSB0dXBsZSBvZiB0aGUgdmFsdWUgZm9sbG93ZWQgYnkgYnl0ZXMgcmVhZC5cbiAqIEB0aHJvd3Mge0Vycm9yfVxuICogICBXaGVuIHRoZSBkYXRhIHN0cmVhbSBlbmRzIGVhcmx5IG9yIHRoZSBDQk9SIGRhdGEgaXMgbm90IHdlbGwgZm9ybWVkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWNvZGVQYXJ0aWFsQ0JPUihkYXRhLCBpbmRleCkge1xuICAgIGlmIChkYXRhLmJ5dGVMZW5ndGggPT09IDAgfHwgZGF0YS5ieXRlTGVuZ3RoIDw9IGluZGV4IHx8IGluZGV4IDwgMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBkYXRhXCIpO1xuICAgIH1cbiAgICBpZiAoZGF0YSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICAgICAgcmV0dXJuIGRlY29kZU5leHQobmV3IERhdGFWaWV3KGRhdGEuYnVmZmVyKSwgaW5kZXgpO1xuICAgIH1cbiAgICBlbHNlIGlmIChkYXRhIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICAgICAgcmV0dXJuIGRlY29kZU5leHQobmV3IERhdGFWaWV3KGRhdGEpLCBpbmRleCk7XG4gICAgfVxuICAgIC8vIG90aGVyd2lzZSwgaXQgaXMgYSBkYXRhIHZpZXdcbiAgICByZXR1cm4gZGVjb2RlTmV4dChkYXRhLCBpbmRleCk7XG59XG4vKipcbiAqIERlY29kZSBDQk9SIGRhdGEgZnJvbSBhIGJpbmFyeSBzdHJlYW1cbiAqXG4gKiBUaGUgZW50aXJlIGRhdGEgc3RyZWFtIGZyb20gWzAsIGxlbmd0aCkgd2lsbCBiZSBjb25zdW1lZC5cbiAqIElmIHlvdSByZXF1aXJlIGEgcGFydGlhbCBkZWNvZGluZywgc2VlIHtkZWNvZGVQYXJ0aWFsQ0JPUn0uXG4gKlxuICogRXhhbXBsZXM6XG4gKlxuICogYGBgdHNcbiAqIGltcG9ydCB7ZGVjb2RlQ0JPUiwgQ0JPUlRhZywgQ0JPUlR5cGV9IGZyb20gJy4vY2Jvci50cydcbiAqIGRlY29kZUNCT1IobmV3IFVpbnQ4QXJyYXkoWzE2MiwgOTksIDEwNywgMTAxLCAxMjEsIDEwMSwgMTE4LCA5NywgMTA4LCAxMTcsIDEwMSwgMSwgMTA5LCA5NywgMTEwLCAxMTEsIDExNiwgMTA0LCAxMDEsIDExNCwgMzIsIDExOCwgOTcsIDEwOCwgMTE3LCAxMDFdKSk7XG4gKiAvLyByZXR1cm5zIG5ldyBNYXA8c3RyaW5nIHwgbnVtYmVyLCBDQk9SVHlwZT4oW1xuICogLy8gICBbXCJrZXlcIiwgXCJ2YWx1ZVwiXSxcbiAqIC8vICAgWzEsIFwiYW5vdGhlciB2YWx1ZVwiXVxuICogLy8gXSk7XG4gKlxuICogY29uc3QgdGFnZ2VkSXRlbSA9IG5ldyBVaW50OEFycmF5KFsyMTcsIDQsIDIxMCwgMTAxLCAxMDQsIDEwMSwgMTA4LCAxMDgsIDExMV0pO1xuICogZGVjb2RlQ0JPUihuZXcgRGF0YVZpZXcodGFnZ2VkSXRlbS5idWZmZXIpKVxuICogLy8gcmV0dXJucyBuZXcgQ0JPUlRhZygxMjM0LCBcImhlbGxvXCIpXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gZGF0YSBhIGRhdGEgc3RyZWFtLCBtdWx0aXBsZSB0eXBlcyBhcmUgc3VwcG9ydGVkXG4gKiBAcmV0dXJuc1xuICovXG5leHBvcnQgZnVuY3Rpb24gZGVjb2RlQ0JPUihkYXRhKSB7XG4gICAgY29uc3QgW3ZhbHVlLCBsZW5ndGhdID0gZGVjb2RlUGFydGlhbENCT1IoZGF0YSwgMCk7XG4gICAgaWYgKGxlbmd0aCAhPT0gZGF0YS5ieXRlTGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRGF0YSB3YXMgZGVjb2RlZCwgYnV0IHRoZSB3aG9sZSBzdHJlYW0gd2FzIG5vdCBwcm9jZXNzZWQgJHtsZW5ndGh9ICE9ICR7ZGF0YS5ieXRlTGVuZ3RofWApO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG59XG4vKipcbiAqIEVuY29kZSBhIHN1cHBvcnRlZCBzdHJ1Y3R1cmUgdG8gYSBDQk9SIGJ5dGUgc3RyaW5nLlxuICpcbiAqIEV4YW1wbGU6XG4gKlxuICogYGBgdHNcbiAqIGltcG9ydCB7ZW5jb2RlQ0JPUiwgQ0JPUlR5cGUsIENCT1JUYWd9IGZyb20gJy4vY2Jvci50cydcbiAqIGVuY29kZUNCT1IobmV3IE1hcDxzdHJpbmcgfCBudW1iZXIsIENCT1JUeXBlPihbXG4gKiAgIFtcImtleVwiLCBcInZhbHVlXCJdLFxuICogICBbMSwgXCJhbm90aGVyIHZhbHVlXCJdXG4gKiBdKSk7XG4gKiAvLyByZXR1cm5zIG5ldyBVaW50OEFycmF5KFsxNjIsIDk5LCAxMDcsIDEwMSwgMTIxLCAxMDEsIDExOCwgOTcsIDEwOCwgMTE3LCAxMDEsIDEsIDEwOSwgOTcsIDExMCwgMTExLCAxMTYsIDEwNCwgMTAxLCAxMTQsIDMyIDExOCwgOTcsIDEwOCwgMTE3LCAxMDFdKVxuICpcbiAqIGVuY29kZUNCT1IobmV3IENCT1JUYWcoMTIzNCwgXCJoZWxsb1wiKSlcbiAqIC8vIHJldHVybnMgbmV3IFVJbnQ4QXJyYXkoWzIxNywgNCwgMjEwLCAxMDEsIDEwNCwgMTAxLCAxMDgsIDEwOCwgMTExXSlcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBkYXRhIERhdGEgdG8gZW5jb2RlXG4gKiBAcmV0dXJucyBBIGJ5dGUgc3RyaW5nIGFzIGEgVWludDhBcnJheVxuICogQHRocm93cyBFcnJvclxuICogICBpZiB1bnN1cHBvcnRlZCBkYXRhIGlzIGZvdW5kIGR1cmluZyBlbmNvZGluZ1xuICovXG5leHBvcnQgZnVuY3Rpb24gZW5jb2RlQ0JPUihkYXRhKSB7XG4gICAgY29uc3QgcmVzdWx0cyA9IFtdO1xuICAgIGVuY29kZVBhcnRpYWxDQk9SKGRhdGEsIHJlc3VsdHMpO1xuICAgIGxldCBsZW5ndGggPSAwO1xuICAgIGZvciAoY29uc3QgcmVzdWx0IG9mIHJlc3VsdHMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiByZXN1bHQgPT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgbGVuZ3RoICs9IDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZW5ndGggKz0gcmVzdWx0Lmxlbmd0aDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBvdXRwdXQgPSBuZXcgVWludDhBcnJheShsZW5ndGgpO1xuICAgIGxldCBpbmRleCA9IDA7XG4gICAgZm9yIChjb25zdCByZXN1bHQgb2YgcmVzdWx0cykge1xuICAgICAgICBpZiAodHlwZW9mIHJlc3VsdCA9PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICBvdXRwdXRbaW5kZXhdID0gcmVzdWx0O1xuICAgICAgICAgICAgaW5kZXggKz0gMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG91dHB1dC5zZXQocmVzdWx0LCBpbmRleCk7XG4gICAgICAgICAgICBpbmRleCArPSByZXN1bHQubGVuZ3RoO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvdXRwdXQ7XG59XG4iXSwibmFtZXMiOlsiZGVjb2RlTGVuZ3RoIiwiZW5jb2RlTGVuZ3RoIiwiTUFKT1JfVFlQRV9BUlJBWSIsIk1BSk9SX1RZUEVfQllURV9TVFJJTkciLCJNQUpPUl9UWVBFX01BUCIsIk1BSk9SX1RZUEVfTkVHQVRJVkVfSU5URUdFUiIsIk1BSk9SX1RZUEVfU0lNUExFX09SX0ZMT0FUIiwiTUFKT1JfVFlQRV9UQUciLCJNQUpPUl9UWVBFX1RFWFRfU1RSSU5HIiwiTUFKT1JfVFlQRV9VTlNJR05FRF9JTlRFR0VSIiwiQ0JPUlRhZyIsImNvbnN0cnVjdG9yIiwidGFnIiwidmFsdWUiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImVudW1lcmFibGUiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSIsInRhZ0lkIiwidGFnVmFsdWUiLCJkZWNvZGVVbnNpZ25lZEludGVnZXIiLCJkYXRhIiwiYXJndW1lbnQiLCJpbmRleCIsImRlY29kZU5lZ2F0aXZlSW50ZWdlciIsImxlbmd0aCIsImRlY29kZUJ5dGVTdHJpbmciLCJsZW5ndGhWYWx1ZSIsImxlbmd0aENvbnN1bWVkIiwiZGF0YVN0YXJ0SW5kZXgiLCJVaW50OEFycmF5IiwiYnVmZmVyIiwic2xpY2UiLCJURVhUX0RFQ09ERVIiLCJUZXh0RGVjb2RlciIsImRlY29kZVN0cmluZyIsImRlY29kZSIsImRlY29kZUFycmF5IiwiY29uc3VtZWRMZW5ndGgiLCJpIiwicmVtYWluaW5nRGF0YUxlbmd0aCIsImJ5dGVMZW5ndGgiLCJFcnJvciIsImRlY29kZWRWYWx1ZSIsImNvbnN1bWVkIiwiZGVjb2RlTmV4dCIsInB1c2giLCJNQVBfRVJST1IiLCJkZWNvZGVNYXAiLCJNYXAiLCJyZXN1bHQiLCJrZXkiLCJrZXlDb25zdW1lZCIsImhhcyIsInZhbHVlQ29uc3VtZWQiLCJzZXQiLCJkZWNvZGVGbG9hdDE2IiwiZ2V0VWludDE2IiwiSW5maW5pdHkiLCJOYU4iLCJkZWNvZGVGbG9hdDMyIiwiZ2V0RmxvYXQzMiIsImRlY29kZUZsb2F0NjQiLCJnZXRGbG9hdDY0IiwiZGVjb2RlVGFnIiwidGFnQnl0ZXMiLCJ2YWx1ZUJ5dGVzIiwiYnl0ZSIsImdldFVpbnQ4IiwibWFqb3JUeXBlIiwidW5kZWZpbmVkIiwiZW5jb2RlU2ltcGxlIiwiZW5jb2RlRmxvYXQiLCJNYXRoIiwiZnJvdW5kIiwiTnVtYmVyIiwiaXNGaW5pdGUiLCJpc05hTiIsIm91dHB1dCIsInZpZXciLCJEYXRhVmlldyIsInNldEZsb2F0MzIiLCJzZXRGbG9hdDY0IiwiZW5jb2RlTnVtYmVyIiwiaXNTYWZlSW50ZWdlciIsImFicyIsIkVOQ09ERVIiLCJUZXh0RW5jb2RlciIsImVuY29kZVN0cmluZyIsImVuY29kZSIsImVuY29kZUJ5dGVzIiwiZW5jb2RlQXJyYXkiLCJlbGVtZW50IiwiZW5jb2RlUGFydGlhbENCT1IiLCJlbmNvZGVNYXAiLCJzaXplIiwiZW50cmllcyIsImVuY29kZVRhZyIsIkFycmF5IiwiaXNBcnJheSIsImRlY29kZVBhcnRpYWxDQk9SIiwiQXJyYXlCdWZmZXIiLCJkZWNvZGVDQk9SIiwiZW5jb2RlQ0JPUiIsInJlc3VsdHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@levischuck/tiny-cbor/esm/cbor/cbor.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@levischuck/tiny-cbor/esm/cbor/cbor_internal.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@levischuck/tiny-cbor/esm/cbor/cbor_internal.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MAJOR_TYPE_ARRAY: () => (/* binding */ MAJOR_TYPE_ARRAY),\n/* harmony export */   MAJOR_TYPE_BYTE_STRING: () => (/* binding */ MAJOR_TYPE_BYTE_STRING),\n/* harmony export */   MAJOR_TYPE_MAP: () => (/* binding */ MAJOR_TYPE_MAP),\n/* harmony export */   MAJOR_TYPE_NEGATIVE_INTEGER: () => (/* binding */ MAJOR_TYPE_NEGATIVE_INTEGER),\n/* harmony export */   MAJOR_TYPE_SIMPLE_OR_FLOAT: () => (/* binding */ MAJOR_TYPE_SIMPLE_OR_FLOAT),\n/* harmony export */   MAJOR_TYPE_TAG: () => (/* binding */ MAJOR_TYPE_TAG),\n/* harmony export */   MAJOR_TYPE_TEXT_STRING: () => (/* binding */ MAJOR_TYPE_TEXT_STRING),\n/* harmony export */   MAJOR_TYPE_UNSIGNED_INTEGER: () => (/* binding */ MAJOR_TYPE_UNSIGNED_INTEGER),\n/* harmony export */   decodeLength: () => (/* binding */ decodeLength),\n/* harmony export */   encodeLength: () => (/* binding */ encodeLength)\n/* harmony export */ });\nfunction decodeLength(data, argument, index) {\n    if (argument < 24) {\n        return [\n            argument,\n            1\n        ];\n    }\n    const remainingDataLength = data.byteLength - index - 1;\n    const view = new DataView(data.buffer, index + 1);\n    let output;\n    let bytes = 0;\n    switch(argument){\n        case 24:\n            {\n                if (remainingDataLength > 0) {\n                    output = view.getUint8(0);\n                    bytes = 2;\n                }\n                break;\n            }\n        case 25:\n            {\n                if (remainingDataLength > 1) {\n                    output = view.getUint16(0, false);\n                    bytes = 3;\n                }\n                break;\n            }\n        case 26:\n            {\n                if (remainingDataLength > 3) {\n                    output = view.getUint32(0, false);\n                    bytes = 5;\n                }\n                break;\n            }\n        case 27:\n            {\n                if (remainingDataLength > 7) {\n                    const bigOutput = view.getBigUint64(0, false);\n                    // Bound it to [24, MAX_SAFE_INTEGER], where it is safe\n                    // to encode as a javascript number\n                    if (bigOutput >= 24n && bigOutput <= Number.MAX_SAFE_INTEGER) {\n                        return [\n                            Number(bigOutput),\n                            9\n                        ];\n                    }\n                }\n                break;\n            }\n    }\n    if (output && output >= 24) {\n        return [\n            output,\n            bytes\n        ];\n    }\n    throw new Error(\"Length not supported or not well formed\");\n}\nconst MAJOR_TYPE_UNSIGNED_INTEGER = 0;\nconst MAJOR_TYPE_NEGATIVE_INTEGER = 1;\nconst MAJOR_TYPE_BYTE_STRING = 2;\nconst MAJOR_TYPE_TEXT_STRING = 3;\nconst MAJOR_TYPE_ARRAY = 4;\nconst MAJOR_TYPE_MAP = 5;\nconst MAJOR_TYPE_TAG = 6;\nconst MAJOR_TYPE_SIMPLE_OR_FLOAT = 7;\nfunction encodeLength(major, argument) {\n    const majorEncoded = major << 5;\n    if (argument < 0) {\n        throw new Error(\"CBOR Data Item argument must not be negative\");\n    }\n    // Convert to bigint first.\n    // Encode integers around and above 32 bits in big endian / network byte order\n    // is unreliable in javascript.\n    // https://tc39.es/ecma262/#sec-bitwise-shift-operators\n    // Bit shifting operations result in 32 bit signed numbers\n    let bigintArgument;\n    if (typeof argument == \"number\") {\n        if (!Number.isInteger(argument)) {\n            throw new Error(\"CBOR Data Item argument must be an integer\");\n        }\n        bigintArgument = BigInt(argument);\n    } else {\n        bigintArgument = argument;\n    }\n    // Negative 0 is not a thing\n    if (major == MAJOR_TYPE_NEGATIVE_INTEGER) {\n        if (bigintArgument == 0n) {\n            throw new Error(\"CBOR Data Item argument cannot be zero when negative\");\n        }\n        bigintArgument = bigintArgument - 1n;\n    }\n    if (bigintArgument > 18446744073709551615n) {\n        throw new Error(\"CBOR number out of range\");\n    }\n    // Encode into 64 bits and extract the tail\n    const buffer = new Uint8Array(8);\n    const view = new DataView(buffer.buffer);\n    view.setBigUint64(0, bigintArgument, false);\n    if (bigintArgument <= 23) {\n        return [\n            majorEncoded | buffer[7]\n        ];\n    } else if (bigintArgument <= 255) {\n        return [\n            majorEncoded | 24,\n            buffer[7]\n        ];\n    } else if (bigintArgument <= 65535) {\n        return [\n            majorEncoded | 25,\n            ...buffer.slice(6)\n        ];\n    } else if (bigintArgument <= 4294967295) {\n        return [\n            majorEncoded | 26,\n            ...buffer.slice(4)\n        ];\n    } else {\n        return [\n            majorEncoded | 27,\n            ...buffer\n        ];\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxldmlzY2h1Y2svdGlueS1jYm9yL2VzbS9jYm9yL2Nib3JfaW50ZXJuYWwuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUFPLFNBQVNBLGFBQWFDLElBQUksRUFBRUMsUUFBUSxFQUFFQyxLQUFLO0lBQzlDLElBQUlELFdBQVcsSUFBSTtRQUNmLE9BQU87WUFBQ0E7WUFBVTtTQUFFO0lBQ3hCO0lBQ0EsTUFBTUUsc0JBQXNCSCxLQUFLSSxVQUFVLEdBQUdGLFFBQVE7SUFDdEQsTUFBTUcsT0FBTyxJQUFJQyxTQUFTTixLQUFLTyxNQUFNLEVBQUVMLFFBQVE7SUFDL0MsSUFBSU07SUFDSixJQUFJQyxRQUFRO0lBQ1osT0FBUVI7UUFDSixLQUFLO1lBQUk7Z0JBQ0wsSUFBSUUsc0JBQXNCLEdBQUc7b0JBQ3pCSyxTQUFTSCxLQUFLSyxRQUFRLENBQUM7b0JBQ3ZCRCxRQUFRO2dCQUNaO2dCQUNBO1lBQ0o7UUFDQSxLQUFLO1lBQUk7Z0JBQ0wsSUFBSU4sc0JBQXNCLEdBQUc7b0JBQ3pCSyxTQUFTSCxLQUFLTSxTQUFTLENBQUMsR0FBRztvQkFDM0JGLFFBQVE7Z0JBQ1o7Z0JBQ0E7WUFDSjtRQUNBLEtBQUs7WUFBSTtnQkFDTCxJQUFJTixzQkFBc0IsR0FBRztvQkFDekJLLFNBQVNILEtBQUtPLFNBQVMsQ0FBQyxHQUFHO29CQUMzQkgsUUFBUTtnQkFDWjtnQkFDQTtZQUNKO1FBQ0EsS0FBSztZQUFJO2dCQUNMLElBQUlOLHNCQUFzQixHQUFHO29CQUN6QixNQUFNVSxZQUFZUixLQUFLUyxZQUFZLENBQUMsR0FBRztvQkFDdkMsdURBQXVEO29CQUN2RCxtQ0FBbUM7b0JBQ25DLElBQUlELGFBQWEsR0FBRyxJQUFJQSxhQUFhRSxPQUFPQyxnQkFBZ0IsRUFBRTt3QkFDMUQsT0FBTzs0QkFBQ0QsT0FBT0Y7NEJBQVk7eUJBQUU7b0JBQ2pDO2dCQUNKO2dCQUNBO1lBQ0o7SUFDSjtJQUNBLElBQUlMLFVBQVVBLFVBQVUsSUFBSTtRQUN4QixPQUFPO1lBQUNBO1lBQVFDO1NBQU07SUFDMUI7SUFDQSxNQUFNLElBQUlRLE1BQU07QUFDcEI7QUFDTyxNQUFNQyw4QkFBOEIsRUFBRTtBQUN0QyxNQUFNQyw4QkFBOEIsRUFBRTtBQUN0QyxNQUFNQyx5QkFBeUIsRUFBRTtBQUNqQyxNQUFNQyx5QkFBeUIsRUFBRTtBQUNqQyxNQUFNQyxtQkFBbUIsRUFBRTtBQUMzQixNQUFNQyxpQkFBaUIsRUFBRTtBQUN6QixNQUFNQyxpQkFBaUIsRUFBRTtBQUN6QixNQUFNQyw2QkFBNkIsRUFBRTtBQUNyQyxTQUFTQyxhQUFhQyxLQUFLLEVBQUUxQixRQUFRO0lBQ3hDLE1BQU0yQixlQUFlRCxTQUFTO0lBQzlCLElBQUkxQixXQUFXLEdBQUc7UUFDZCxNQUFNLElBQUlnQixNQUFNO0lBQ3BCO0lBQ0EsMkJBQTJCO0lBQzNCLDhFQUE4RTtJQUM5RSwrQkFBK0I7SUFDL0IsdURBQXVEO0lBQ3ZELDBEQUEwRDtJQUMxRCxJQUFJWTtJQUNKLElBQUksT0FBTzVCLFlBQVksVUFBVTtRQUM3QixJQUFJLENBQUNjLE9BQU9lLFNBQVMsQ0FBQzdCLFdBQVc7WUFDN0IsTUFBTSxJQUFJZ0IsTUFBTTtRQUNwQjtRQUNBWSxpQkFBaUJFLE9BQU85QjtJQUM1QixPQUNLO1FBQ0Q0QixpQkFBaUI1QjtJQUNyQjtJQUNBLDRCQUE0QjtJQUM1QixJQUFJMEIsU0FBU1IsNkJBQTZCO1FBQ3RDLElBQUlVLGtCQUFrQixFQUFFLEVBQUU7WUFDdEIsTUFBTSxJQUFJWixNQUFNO1FBQ3BCO1FBQ0FZLGlCQUFpQkEsaUJBQWlCLEVBQUU7SUFDeEM7SUFDQSxJQUFJQSxpQkFBaUIscUJBQXFCLEVBQUU7UUFDeEMsTUFBTSxJQUFJWixNQUFNO0lBQ3BCO0lBQ0EsMkNBQTJDO0lBQzNDLE1BQU1WLFNBQVMsSUFBSXlCLFdBQVc7SUFDOUIsTUFBTTNCLE9BQU8sSUFBSUMsU0FBU0MsT0FBT0EsTUFBTTtJQUN2Q0YsS0FBSzRCLFlBQVksQ0FBQyxHQUFHSixnQkFBZ0I7SUFDckMsSUFBSUEsa0JBQWtCLElBQUk7UUFDdEIsT0FBTztZQUFDRCxlQUFlckIsTUFBTSxDQUFDLEVBQUU7U0FBQztJQUNyQyxPQUNLLElBQUlzQixrQkFBa0IsS0FBSztRQUM1QixPQUFPO1lBQUNELGVBQWU7WUFBSXJCLE1BQU0sQ0FBQyxFQUFFO1NBQUM7SUFDekMsT0FDSyxJQUFJc0Isa0JBQWtCLE9BQU87UUFDOUIsT0FBTztZQUFDRCxlQUFlO2VBQU9yQixPQUFPMkIsS0FBSyxDQUFDO1NBQUc7SUFDbEQsT0FDSyxJQUFJTCxrQkFBa0IsWUFBWTtRQUNuQyxPQUFPO1lBQ0hELGVBQWU7ZUFDWnJCLE9BQU8yQixLQUFLLENBQUM7U0FDbkI7SUFDTCxPQUNLO1FBQ0QsT0FBTztZQUNITixlQUFlO2VBQ1pyQjtTQUNOO0lBQ0w7QUFDSiIsInNvdXJjZXMiOlsid2VicGFjazovL2NhbXB1cy1taW5kLy4vbm9kZV9tb2R1bGVzL0BsZXZpc2NodWNrL3RpbnktY2Jvci9lc20vY2Jvci9jYm9yX2ludGVybmFsLmpzPzk3YjAiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGZ1bmN0aW9uIGRlY29kZUxlbmd0aChkYXRhLCBhcmd1bWVudCwgaW5kZXgpIHtcbiAgICBpZiAoYXJndW1lbnQgPCAyNCkge1xuICAgICAgICByZXR1cm4gW2FyZ3VtZW50LCAxXTtcbiAgICB9XG4gICAgY29uc3QgcmVtYWluaW5nRGF0YUxlbmd0aCA9IGRhdGEuYnl0ZUxlbmd0aCAtIGluZGV4IC0gMTtcbiAgICBjb25zdCB2aWV3ID0gbmV3IERhdGFWaWV3KGRhdGEuYnVmZmVyLCBpbmRleCArIDEpO1xuICAgIGxldCBvdXRwdXQ7XG4gICAgbGV0IGJ5dGVzID0gMDtcbiAgICBzd2l0Y2ggKGFyZ3VtZW50KSB7XG4gICAgICAgIGNhc2UgMjQ6IHtcbiAgICAgICAgICAgIGlmIChyZW1haW5pbmdEYXRhTGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIG91dHB1dCA9IHZpZXcuZ2V0VWludDgoMCk7XG4gICAgICAgICAgICAgICAgYnl0ZXMgPSAyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAyNToge1xuICAgICAgICAgICAgaWYgKHJlbWFpbmluZ0RhdGFMZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0ID0gdmlldy5nZXRVaW50MTYoMCwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIGJ5dGVzID0gMztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgMjY6IHtcbiAgICAgICAgICAgIGlmIChyZW1haW5pbmdEYXRhTGVuZ3RoID4gMykge1xuICAgICAgICAgICAgICAgIG91dHB1dCA9IHZpZXcuZ2V0VWludDMyKDAsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICBieXRlcyA9IDU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIDI3OiB7XG4gICAgICAgICAgICBpZiAocmVtYWluaW5nRGF0YUxlbmd0aCA+IDcpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBiaWdPdXRwdXQgPSB2aWV3LmdldEJpZ1VpbnQ2NCgwLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgLy8gQm91bmQgaXQgdG8gWzI0LCBNQVhfU0FGRV9JTlRFR0VSXSwgd2hlcmUgaXQgaXMgc2FmZVxuICAgICAgICAgICAgICAgIC8vIHRvIGVuY29kZSBhcyBhIGphdmFzY3JpcHQgbnVtYmVyXG4gICAgICAgICAgICAgICAgaWYgKGJpZ091dHB1dCA+PSAyNG4gJiYgYmlnT3V0cHV0IDw9IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbTnVtYmVyKGJpZ091dHB1dCksIDldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChvdXRwdXQgJiYgb3V0cHV0ID49IDI0KSB7XG4gICAgICAgIHJldHVybiBbb3V0cHV0LCBieXRlc107XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihcIkxlbmd0aCBub3Qgc3VwcG9ydGVkIG9yIG5vdCB3ZWxsIGZvcm1lZFwiKTtcbn1cbmV4cG9ydCBjb25zdCBNQUpPUl9UWVBFX1VOU0lHTkVEX0lOVEVHRVIgPSAwO1xuZXhwb3J0IGNvbnN0IE1BSk9SX1RZUEVfTkVHQVRJVkVfSU5URUdFUiA9IDE7XG5leHBvcnQgY29uc3QgTUFKT1JfVFlQRV9CWVRFX1NUUklORyA9IDI7XG5leHBvcnQgY29uc3QgTUFKT1JfVFlQRV9URVhUX1NUUklORyA9IDM7XG5leHBvcnQgY29uc3QgTUFKT1JfVFlQRV9BUlJBWSA9IDQ7XG5leHBvcnQgY29uc3QgTUFKT1JfVFlQRV9NQVAgPSA1O1xuZXhwb3J0IGNvbnN0IE1BSk9SX1RZUEVfVEFHID0gNjtcbmV4cG9ydCBjb25zdCBNQUpPUl9UWVBFX1NJTVBMRV9PUl9GTE9BVCA9IDc7XG5leHBvcnQgZnVuY3Rpb24gZW5jb2RlTGVuZ3RoKG1ham9yLCBhcmd1bWVudCkge1xuICAgIGNvbnN0IG1ham9yRW5jb2RlZCA9IG1ham9yIDw8IDU7XG4gICAgaWYgKGFyZ3VtZW50IDwgMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDQk9SIERhdGEgSXRlbSBhcmd1bWVudCBtdXN0IG5vdCBiZSBuZWdhdGl2ZVwiKTtcbiAgICB9XG4gICAgLy8gQ29udmVydCB0byBiaWdpbnQgZmlyc3QuXG4gICAgLy8gRW5jb2RlIGludGVnZXJzIGFyb3VuZCBhbmQgYWJvdmUgMzIgYml0cyBpbiBiaWcgZW5kaWFuIC8gbmV0d29yayBieXRlIG9yZGVyXG4gICAgLy8gaXMgdW5yZWxpYWJsZSBpbiBqYXZhc2NyaXB0LlxuICAgIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYml0d2lzZS1zaGlmdC1vcGVyYXRvcnNcbiAgICAvLyBCaXQgc2hpZnRpbmcgb3BlcmF0aW9ucyByZXN1bHQgaW4gMzIgYml0IHNpZ25lZCBudW1iZXJzXG4gICAgbGV0IGJpZ2ludEFyZ3VtZW50O1xuICAgIGlmICh0eXBlb2YgYXJndW1lbnQgPT0gXCJudW1iZXJcIikge1xuICAgICAgICBpZiAoIU51bWJlci5pc0ludGVnZXIoYXJndW1lbnQpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDQk9SIERhdGEgSXRlbSBhcmd1bWVudCBtdXN0IGJlIGFuIGludGVnZXJcIik7XG4gICAgICAgIH1cbiAgICAgICAgYmlnaW50QXJndW1lbnQgPSBCaWdJbnQoYXJndW1lbnQpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgYmlnaW50QXJndW1lbnQgPSBhcmd1bWVudDtcbiAgICB9XG4gICAgLy8gTmVnYXRpdmUgMCBpcyBub3QgYSB0aGluZ1xuICAgIGlmIChtYWpvciA9PSBNQUpPUl9UWVBFX05FR0FUSVZFX0lOVEVHRVIpIHtcbiAgICAgICAgaWYgKGJpZ2ludEFyZ3VtZW50ID09IDBuKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDQk9SIERhdGEgSXRlbSBhcmd1bWVudCBjYW5ub3QgYmUgemVybyB3aGVuIG5lZ2F0aXZlXCIpO1xuICAgICAgICB9XG4gICAgICAgIGJpZ2ludEFyZ3VtZW50ID0gYmlnaW50QXJndW1lbnQgLSAxbjtcbiAgICB9XG4gICAgaWYgKGJpZ2ludEFyZ3VtZW50ID4gMTg0NDY3NDQwNzM3MDk1NTE2MTVuKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNCT1IgbnVtYmVyIG91dCBvZiByYW5nZVwiKTtcbiAgICB9XG4gICAgLy8gRW5jb2RlIGludG8gNjQgYml0cyBhbmQgZXh0cmFjdCB0aGUgdGFpbFxuICAgIGNvbnN0IGJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KDgpO1xuICAgIGNvbnN0IHZpZXcgPSBuZXcgRGF0YVZpZXcoYnVmZmVyLmJ1ZmZlcik7XG4gICAgdmlldy5zZXRCaWdVaW50NjQoMCwgYmlnaW50QXJndW1lbnQsIGZhbHNlKTtcbiAgICBpZiAoYmlnaW50QXJndW1lbnQgPD0gMjMpIHtcbiAgICAgICAgcmV0dXJuIFttYWpvckVuY29kZWQgfCBidWZmZXJbN11dO1xuICAgIH1cbiAgICBlbHNlIGlmIChiaWdpbnRBcmd1bWVudCA8PSAyNTUpIHtcbiAgICAgICAgcmV0dXJuIFttYWpvckVuY29kZWQgfCAyNCwgYnVmZmVyWzddXTtcbiAgICB9XG4gICAgZWxzZSBpZiAoYmlnaW50QXJndW1lbnQgPD0gNjU1MzUpIHtcbiAgICAgICAgcmV0dXJuIFttYWpvckVuY29kZWQgfCAyNSwgLi4uYnVmZmVyLnNsaWNlKDYpXTtcbiAgICB9XG4gICAgZWxzZSBpZiAoYmlnaW50QXJndW1lbnQgPD0gNDI5NDk2NzI5NSkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgbWFqb3JFbmNvZGVkIHwgMjYsXG4gICAgICAgICAgICAuLi5idWZmZXIuc2xpY2UoNCksXG4gICAgICAgIF07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgbWFqb3JFbmNvZGVkIHwgMjcsXG4gICAgICAgICAgICAuLi5idWZmZXIsXG4gICAgICAgIF07XG4gICAgfVxufVxuIl0sIm5hbWVzIjpbImRlY29kZUxlbmd0aCIsImRhdGEiLCJhcmd1bWVudCIsImluZGV4IiwicmVtYWluaW5nRGF0YUxlbmd0aCIsImJ5dGVMZW5ndGgiLCJ2aWV3IiwiRGF0YVZpZXciLCJidWZmZXIiLCJvdXRwdXQiLCJieXRlcyIsImdldFVpbnQ4IiwiZ2V0VWludDE2IiwiZ2V0VWludDMyIiwiYmlnT3V0cHV0IiwiZ2V0QmlnVWludDY0IiwiTnVtYmVyIiwiTUFYX1NBRkVfSU5URUdFUiIsIkVycm9yIiwiTUFKT1JfVFlQRV9VTlNJR05FRF9JTlRFR0VSIiwiTUFKT1JfVFlQRV9ORUdBVElWRV9JTlRFR0VSIiwiTUFKT1JfVFlQRV9CWVRFX1NUUklORyIsIk1BSk9SX1RZUEVfVEVYVF9TVFJJTkciLCJNQUpPUl9UWVBFX0FSUkFZIiwiTUFKT1JfVFlQRV9NQVAiLCJNQUpPUl9UWVBFX1RBRyIsIk1BSk9SX1RZUEVfU0lNUExFX09SX0ZMT0FUIiwiZW5jb2RlTGVuZ3RoIiwibWFqb3IiLCJtYWpvckVuY29kZWQiLCJiaWdpbnRBcmd1bWVudCIsImlzSW50ZWdlciIsIkJpZ0ludCIsIlVpbnQ4QXJyYXkiLCJzZXRCaWdVaW50NjQiLCJzbGljZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@levischuck/tiny-cbor/esm/cbor/cbor_internal.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@levischuck/tiny-cbor/esm/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/@levischuck/tiny-cbor/esm/index.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CBORTag: () => (/* reexport safe */ _cbor_cbor_js__WEBPACK_IMPORTED_MODULE_0__.CBORTag),\n/* harmony export */   decodeCBOR: () => (/* reexport safe */ _cbor_cbor_js__WEBPACK_IMPORTED_MODULE_0__.decodeCBOR),\n/* harmony export */   decodePartialCBOR: () => (/* reexport safe */ _cbor_cbor_js__WEBPACK_IMPORTED_MODULE_0__.decodePartialCBOR),\n/* harmony export */   encodeCBOR: () => (/* reexport safe */ _cbor_cbor_js__WEBPACK_IMPORTED_MODULE_0__.encodeCBOR)\n/* harmony export */ });\n/* harmony import */ var _cbor_cbor_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./cbor/cbor.js */ \"(rsc)/./node_modules/@levischuck/tiny-cbor/esm/cbor/cbor.js\");\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGxldmlzY2h1Y2svdGlueS1jYm9yL2VzbS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFxRiIsInNvdXJjZXMiOlsid2VicGFjazovL2NhbXB1cy1taW5kLy4vbm9kZV9tb2R1bGVzL0BsZXZpc2NodWNrL3RpbnktY2Jvci9lc20vaW5kZXguanM/NGMwOCJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgeyBDQk9SVGFnLCBkZWNvZGVDQk9SLCBkZWNvZGVQYXJ0aWFsQ0JPUiwgZW5jb2RlQ0JPUiwgfSBmcm9tIFwiLi9jYm9yL2Nib3IuanNcIjtcbiJdLCJuYW1lcyI6WyJDQk9SVGFnIiwiZGVjb2RlQ0JPUiIsImRlY29kZVBhcnRpYWxDQk9SIiwiZW5jb2RlQ0JPUiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@levischuck/tiny-cbor/esm/index.js\n");

/***/ })

};
;